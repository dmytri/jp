#!/bin/bash
# Copyright 2021 David Farrell
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
declare JP_LINE=0 JP_COL=0 JP_C= JP_OUT=() JP_TOKENS=() JP_INDENT="  " JP_PRETTY= JP_SILENT= JP_ATOM_LEN= JP_INPUT=

function jp.error {
  echo "Error: $1 at line $JP_LINE, column $JP_COL" >&2
  return 1
}

function jp.trace {
  # ignore non-jp functions and duplicate DEBUG signals
  if [[ "$1" == "jp."* ]] && [[ "$1" != "${FUNCNAME[1]}" ]]; then
    printf "%s\t%s\n" "$EPOCHREALTIME" "$1" >&2
  fi
}

# BEGIN PARSE FUNCTIONS
function jp.chomp {
  if (( JP_COL < "${#JP_BUF[$JP_LINE]}" ));then
    JP_C="${JP_BUF[$JP_LINE]:$JP_COL:1}"
    (( JP_COL++ ))
  elif (( JP_COL == "${#JP_BUF[$JP_LINE]}" ));then
    JP_C=$'\n'
    (( JP_COL++ ))
  else
    (( JP_LINE++ ))
    JP_C="${JP_BUF[$JP_LINE]:0:1}"
    JP_COL=1
  fi
}

function jp.drop_ws {
  while :;do
    if [[ "$JP_C" == [[:blank:]$'\n\r'] ]];then
      jp.chomp
    else
      break
    fi
  done
}

function jp.expect {
  if [[ "$JP_C" != "$1" ]];then
    local msg
    printf -v msg "expected %q but found %q" "$1" "$JP_C"
    jp.error "$msg" || return
  fi
}

function jp.array {
  JP_TOKENS+=("[")
  jp.chomp
  jp.drop_ws
  if [[ "$JP_C" != ']' ]];then
    jp.read_next || return
    while :;do
      [[ "$JP_C" != '' ]] || jp.error "unterminated array: didn't find ]" || return
      jp.drop_ws
      if [[ "$JP_C" == ']' ]];then
        break
      elif [[ "$JP_C" == ',' ]];then
        JP_TOKENS+=(",")
        jp.chomp
        jp.drop_ws
        jp.read_next || return
      else
        jp.error "expected , or ] but found '$JP_C'" || return
      fi
    done
  fi
  JP_TOKENS+=("]")
  jp.chomp
}

function jp.object {
  JP_TOKENS+=("{")
  jp.chomp
  jp.drop_ws
  if [[ "$JP_C" != '}' ]];then
    jp.expect '"' || return
    jp.string
    jp.drop_ws
    jp.expect ":" || return
    JP_TOKENS+=(":")
    jp.chomp
    jp.drop_ws
    jp.read_next || return
    while :;do
      [[ "$JP_C" != '' ]] || jp.error "unterminated object: didn't find }" return
      jp.drop_ws
      if [[ "$JP_C" == '}' ]];then
        break
      elif [[ "$JP_C" == ',' ]];then
        JP_TOKENS+=(",")
        jp.chomp
        jp.drop_ws
        jp.expect '"' || return
        jp.string
        jp.drop_ws
        jp.expect ":" || return
        JP_TOKENS+=(":")
        jp.chomp
        jp.drop_ws
        jp.read_next || return
      else
        jp.error "expected , or } but found $JP_C" || return
      fi
    done
  fi
  JP_TOKENS+=("}")
  jp.chomp
}

function jp.number {
  local num="$JP_C" seendot= seenexp=
  jp.chomp
  if [[ "$num" == '-' ]];then # negative number
    [[ "$JP_C" == [[:digit:]] ]] || jp.error "minus not followed by digit: $num$JP_C" || return
    if [[ "$JP_C" == '0' ]];then
      num="$num$JP_C"
      jp.chomp
      [[ "$JP_C" != [[:digit:]] ]] || jp.error "number starts with zero: $num$JP_C" || return
    fi
  elif [[ "$num" == '0' ]];then
    [[ $JP_C != [[:digit:]] ]] || jp.error "number starts with zero: $num$JP_C" || return
  fi
  while :;do
    if [[ "$JP_C" == [[:digit:]] ]];then
      num="$num$JP_C"
    elif [[ "$JP_C" == . ]];then
      if [[ "$seendot" ]]; then
        jp.error "number has too many dots in it: $num$JP_C" || return
      elif [[ "$seenexp" ]]; then
        jp.error "exponents cannot contain dots: $num$JP_C" || return
      else
        num="$num$JP_C"
        seendot=1
        jp.chomp
        [[ "$JP_C" == [[:digit:]] ]] || jp.error "dot not followed by digit: $num$JP_C" || return
        continue
      fi
    elif [[ $JP_C == [Ee] ]];then
      if [[ $seenexp ]]; then
        jp.error "number has too many Es in it: $num$JP_C" || return
      fi
      seenexp=1
      num="$num$JP_C"
      jp.chomp
      if [[ $JP_C == [+-] ]];then
        num="$num$JP_C"
        jp.chomp
      fi
      if [[ $JP_C != [[:digit:]] ]];then
        jp.error "a number must follow an exponent or sign: $num$JP_C" || return
      fi
      num="$num$JP_C"
    else
      JP_TOKENS+=("$num")
      break
    fi
    jp.chomp
  done
  lastchar=${num:$(( ${#num}-1 )):1}
  [[ "$lastchar" != [Ee.+-] ]] || jp.error "invalid number $num ($lastchar)" || return
}

function jp.string {
  local str= start_line="$JP_LINE"
  while :;do
    [[ "$JP_C" != '' ]] || jp.error "unterminated string: didn't find \"" || return
    jp.chomp
    if [[ "$JP_LINE" > "$start_line" ]];then
      jp.error "unescaped newline in string" || return
    elif [[ "$JP_C" == $'\t' ]];then
      jp.error "unescaped tab in string" || return
    elif [[ "$JP_C" == $'\\' ]];then # handle escapes
      str="$str$JP_C"
      jp.chomp
      if [[ "$JP_C" == u ]];then # unicode
        local esc="u"
        for i in 1 2 3 4;do
          jp.chomp
          [[ "$JP_C" == [0-9A-Fa-f] ]] || jp.error "invalid Unicode escape sequence \\$esc$JP_C" || return
          esc+="$JP_C"
        done
        JP_C="$esc"
      elif [[ "$JP_C" != [bfnrt\"$'\\'/] ]];then
        jp.error "invalid escape sequence in string: \\$JP_C" || return
      fi
    elif [[ "$JP_C" == '"' ]];then
      JP_TOKENS+=("\"$str\"")
      break
    fi
    str+="$JP_C"
  done
  jp.chomp
}

function jp.null {
  jp.chomp
  if [[ "$JP_C" == "u" ]];then
    jp.chomp
    if [[ "$JP_C" == "l" ]];then
      jp.chomp
      if [[ "$JP_C" == "l" ]];then
        JP_TOKENS+=("null")
        jp.chomp
        return
      fi
    fi
  fi
  jp.error "expected 'null' but saw '$JP_C'" || return
}

function jp.bool_true {
  jp.chomp
  if [[ "$JP_C" == "r" ]];then
    jp.chomp
    if [[ "$JP_C" == "u" ]];then
      jp.chomp
      if [[ "$JP_C" == "e" ]];then
        JP_TOKENS+=("true")
        jp.chomp
        return
      fi
    fi
  fi
  jp.error "expected 'true' but saw '$JP_C'" || return
}

function jp.bool_false {
  jp.chomp
  if [[ "$JP_C" == "a" ]];then
    jp.chomp
    if [[ "$JP_C" == "l" ]];then
      jp.chomp
      if [[ "$JP_C" == "s" ]];then
        jp.chomp
        if [[ "$JP_C" == "e" ]];then
          JP_TOKENS+=("false")
          jp.chomp
          return
        fi
      fi
    fi
  fi
  jp.error "expected 'false' but saw '$JP_C'" || return
}

function jp.read_next {
  case "$JP_C" in
    [[:digit:]-]) jp.number;;
    '"') jp.string;;
    'n') jp.null;;
    't') jp.bool_true;;
    'f') jp.bool_false;;
    '[') jp.array;;
    '{') jp.object;;
    *) jp.error "expected 0-9, \", 't', 'f', '[', or '{' but got: '$JP_C'"
  esac
}

function jp.parse_json {
  jp.chomp
  jp.drop_ws
  jp.read_next || return
  while [[ "$JP_C" == [[:blank:]] ]];do
    jp.chomp
  done
  [[ "$JP_C" == $'\n' ]] || jp.error "expected '\n' but found $JP_C" || return
}

function jp.detect_nullbyte {
  local buf=
  IFS= read -rd '' buf
  [[ -z "$buf" ]] || jp.error "received input after null byte" || return
}
# END PARSE FUNCTIONS

# BEGIN TRANSFORM FUNCTIONS
function jp.pop {
  (( JP_STACKSIZE-- )) || jp.error "cannot pop an empty stack" || return
  JP_REF="${JP_STACK[$JP_STACKSIZE]}"
  IFS= eval JP_OUT=("\${$JP_REF[@]}")
  JP_STACK[$JP_STACKSIZE]=
}

function jp.drop {
  jp.pop || return
  if [[ "$JP_OUT" =~ ^[0-9]+$ ]];then
    jp_drop_count="$JP_OUT"
    while (( jp_drop_count-- ));do
      jp.pop || return
    done
  else
    jp.error "can only drop a positive number of items but saw '$JP_OUT'" || return
  fi
}

function jp.push {
  JP_STACK[$JP_STACKSIZE]="$1"
  (( JP_STACKSIZE++ ))
  return 0
}

function jp.dup {
  (( JP_STACKSIZE > 0 )) || jp.error "cannot dup an empty stack" || return
  JP_REF="${JP_STACK[$(( JP_STACKSIZE-1 ))]}"
  (( JP_REFCNT++ ))
  IFS= eval "JP_REF_$JP_REFCNT"='(${'"$JP_REF"'[@]})'
  jp.push "JP_REF_$JP_REFCNT"
}

function jp.swap {
  (( JP_STACKSIZE > 1 )) || jp.error 'swap needs two items on the stack' || return
  JP_REF="${JP_STACK[$(( JP_STACKSIZE-1 ))]}"
  JP_STACK[$(( JP_STACKSIZE-1 ))]="${JP_STACK[$(( JP_STACKSIZE-2 ))]}"
  JP_STACK[$(( JP_STACKSIZE-2 ))]="$JP_REF"
}

function jp.get_atom {
  local i="$1"
  if [ "${JP_OUT[$i]}" = '{' ];then
    local nest_count=0
    while :;do
      (( i++ ))
      if [ "${JP_OUT[$i]}" = '{' ];then
        (( nest_count++ ))
      elif [ "${JP_OUT[$i]}" = '}' ];then
        (( nest_count-- ))
        if [ $nest_count -lt 0 ];then
          (( JP_ATOM_LEN=$i-$1+1 ))
          return
        fi
      fi
    done
  elif [ "${JP_OUT[$i]}" = '[' ];then
    local nest_count=0
    while :;do
      (( i++ ))
      if [ "${JP_OUT[$i]}" = '[' ];then
        (( nest_count++ ))
      elif [ "${JP_OUT[$i]}" == ']' ];then
        (( nest_count-- ))
        if [ $nest_count -lt 0 ];then
          (( JP_ATOM_LEN=$i-$1+1 ))
          return
        fi
      fi
    done
  else
     JP_ATOM_LEN=1
  fi
}

function jp.keys {
  jp.pop || return
  if [ "${JP_OUT[0]}" = '{' ];then
    local i=1 len=$(("${#JP_OUT[@]}"-3))
    while (( i < len ));do
      (( JP_REFCNT++ ))
      IFS= eval "JP_REF_$JP_REFCNT"='("${JP_OUT[$i]}")'
      jp.push "JP_REF_$JP_REFCNT"
      # now skip the :value
      (( i+=2 ))
      jp.get_atom "$i"
      (( i+=1+$JP_ATOM_LEN ))
    done
  else
    jp.error "keys only works on objects" || return
  fi
}

function jp.vals {
  jp.pop || return
  local offset=1
  if [ "${JP_OUT[0]}" = '{' ];then
    offset=3
  elif [ "${JP_OUT[0]}" != '[' ];then
    jp.error "values only works on objects/arrays" || return
  fi
  local i=$offset len=$(("${#JP_OUT[@]}"-1))
  while (( i < len ));do
    jp.get_atom "$i"
    (( JP_REFCNT++ ))
    IFS= eval "JP_REF_$JP_REFCNT"='("${JP_OUT[@]:$i:$JP_ATOM_LEN}")'
    jp.push "JP_REF_$JP_REFCNT"
    (( i+=offset+$JP_ATOM_LEN ))
  done
}

function jp.pairs {
  jp.pop || return
  if [ "${JP_OUT[0]}" = '{' ];then
    local i=1 len=$(("${#JP_OUT[@]}"-3))
    while (( i < len ));do
      local k="${JP_OUT[$i]}"
      (( i+=2))
      jp.get_atom "$i"
      (( JP_REFCNT++ ))
      IFS= eval "JP_REF_$JP_REFCNT"='({ "$k" : "${JP_OUT[@]:$i:$JP_ATOM_LEN}" })'
      jp.push "JP_REF_$JP_REFCNT"
      (( i+=1+$JP_ATOM_LEN ))
    done
  else
    jp.error "pairs only works on objects" || return
  fi
}

function jp.k {
  jp.pop || return
  local k="$JP_OUT" sep=
  [ "${k:0:1}" == '"' ] || jp.error "k requires a string" || return
  if (( JP_STACKSIZE > 0 ));then
    (( JP_REFCNT++ ))
    IFS= eval "JP_REF_$JP_REFCNT"='['
    while (( JP_STACKSIZE ));do
      jp.pop || return
      if [ "${JP_OUT[0]}" = '{' ];then
        # handle nested data
        local j=1 len=$(( "${#JP_OUT[@]}" - 1 ))
        while (( j < len ));do
          if [ "$k" = "${JP_OUT[$j]}" ];then
            (( j+=2 ))
            jp.get_atom "$j"
            IFS= eval "JP_REF_$JP_REFCNT"+='($sep "${JP_OUT[@]:$j:$JP_ATOM_LEN}")'
            sep=','
          else
            (( j+=2 ))
            jp.get_atom "$j"
          fi
          (( j+=1+JP_ATOM_LEN ))
        done
      else
        jp.error "only objects have keys" || return
      fi
    done
    IFS= eval "JP_REF_$JP_REFCNT"+='(])'
    jp.push "JP_REF_$JP_REFCNT"
  fi
}

function jp.i {
  jp.pop || return
  local i="$JP_OUT" sep=
  [[ "$i" =~ ^[0-9]+$ ]] || jp.error "i requires an integer" || return
  if (( JP_STACKSIZE > 0 ));then
    (( JP_REFCNT++ ))
    IFS= eval "JP_REF_$JP_REFCNT"='['
    while (( JP_STACKSIZE ));do
      jp.pop || return
      if [ "${JP_OUT[0]}" = '[' ];then
        # handle nested data
        local j=1 real_i=0 len=$(( "${#JP_OUT[@]}" - 1 ))
        while (( j < len ));do
          jp.get_atom "$j"
          if [ $i -eq $real_i ];then
            IFS= eval "JP_REF_$JP_REFCNT"+='($sep "${JP_OUT[@]:$j:$JP_ATOM_LEN}")'
            sep=','
            break;
          fi
          (( real_i++ ))
          (( j+=1+$JP_ATOM_LEN ))
        done
      else
        jp.error "i only works on arrays" || return
      fi
    done
    IFS= eval "JP_REF_$JP_REFCNT"+='(])'
    jp.push "JP_REF_$JP_REFCNT"
  fi
}

function jp.count {
  local count="$JP_STACKSIZE"
  while (( JP_STACKSIZE ));do
    jp.pop || return
  done
  (( JP_REFCNT++ ))
  IFS= eval "JP_REF_$JP_REFCNT"='($count)'
  jp.push "JP_REF_$JP_REFCNT"
}

function jp.++ {
  jp.pop || return
  if [ "${JP_OUT:0:1}" = '"' ];then
    jp.++_str
  elif [ "${JP_OUT:0:1}" = '[' ];then
    jp.++_collection "[" "]"
  elif [ "${JP_OUT:0:1}" = '{' ];then
    jp.++_collection "{" "}"
  else
    jp.error "++ can only concat strings, arrays or objects"
  fi
}

function jp.++_str {
  local str="${JP_OUT:1:$(("${#JP_OUT}"-2))}"
  while (( JP_STACKSIZE ));do
    jp.pop || return
    str+="${JP_OUT:1:$(("${#JP_OUT}"-2))}"
  done
  (( JP_REFCNT++ ))
  IFS= eval "JP_REF_$JP_REFCNT"='("\"$str\"")'
  jp.push "JP_REF_$JP_REFCNT"
}

function jp.++_collection {
  local start="$1" end="$2" sep len=$(("${#JP_OUT[@]}"-2))
  (( JP_REFCNT++ ))
  if [ $len -gt 0 ];then
    IFS= eval "JP_REF_$JP_REFCNT"='("$start" "${JP_OUT[@]:1:$len}")'
    sep=","
  else
    IFS= eval "JP_REF_$JP_REFCNT"='("$start")'
  fi
  while (( JP_STACKSIZE ));do
    jp.pop || return
    if [ "${JP_OUT:0:1}" = "$start" ];then
      len=$(("${#JP_OUT[@]}"-2))
      if [ $len -gt 0 ];then
        eval "JP_REF_$JP_REFCNT"+='($sep "${JP_OUT[@]:1:$len}")'
        sep=","
      fi
    else
      jp.error "++ was expecting a '$start' but found '${JP_OUT[0]}'" || return
    fi
  done
  IFS= eval "JP_REF_$JP_REFCNT"+='($end)'
  jp.push "JP_REF_$JP_REFCNT"
}

function jp.collect {
  (( JP_REFCNT++ ))
  eval "JP_REF_$JP_REFCNT"='("[")'
  local sep
  while (( JP_STACKSIZE ));do
    jp.pop || return
    eval "JP_REF_$JP_REFCNT"+='($sep "${JP_OUT[@]}")'
    sep=','
  done
  IFS= eval "JP_REF_$JP_REFCNT"+='(])'
  jp.push "JP_REF_$JP_REFCNT"
}

function jp._test {
  local num_op="$1" str_op="$2" sep
  jp.pop || return
  local operand="$JP_OUT" mode
  if [ ${operand[0]:0:1} = '"' ];then
    mode="str"
  elif [[ ${JP_OUT[0]:0:1} == [[:digit:]-] ]];then
    mode="num"
  else
    jp.error "can only compare to strings/numbers but saw '$JP_OUT'" || return
  fi
  (( JP_REFCNT++ ))
  eval "JP_REF_$JP_REFCNT"='("[")'
  while (( JP_STACKSIZE ));do
    jp.pop || return
    if [ "$mode" = 'str' ] && [ ${JP_OUT[0]:0:1} = '"' ];then
      if [ "$JP_OUT" $str_op "$operand" ];then
        IFS= eval "JP_REF_$JP_REFCNT"+='($sep "$JP_OUT")'
        sep=','
      fi
    elif [ "$mode" = 'num' ] && [[ ${JP_OUT[0]:0:1} == [[:digit:]-] ]];then
      if [ $JP_OUT $num_op $operand ];then
        IFS= eval "JP_REF_$JP_REFCNT"+='($sep $JP_OUT)'
        sep=','
      fi
    else
      jp.error "can only filter strings and numbers but saw '$JP_OUT'" || return
    fi
  done
  IFS= eval "JP_REF_$JP_REFCNT"+='(])'
  jp.push "JP_REF_$JP_REFCNT"
}

function jp.eq {
  jp._test "-eq" "="
}

function jp.ne {
  jp._test "-ne" "!="
}

function jp.gt {
  jp._test "-gt" ">"
}

function jp.ge {
  jp._test "-ge" ">"
}

function jp.lt {
  jp._test "-lt" "<"
}

function jp.le {
  jp._test "-le" "<"
}

function jp.=~ {
  jp.pop || return
  if [ ${JP_OUT[0]:0:1} != '"' ];then
    jp.error "=~ requires a string as a pattern" || return
  fi
  local operand="${JP_OUT:1:$(( ${#JP_OUT} -2 ))}" sep
  (( JP_REFCNT++ ))
  eval "JP_REF_$JP_REFCNT"='("[")'
  while (( JP_STACKSIZE ));do
    jp.pop || return
    if [ ${JP_OUT[0]:0:1} == '"' ];then # remove "
      if [[ "${JP_OUT:1:$(( ${#JP_OUT} -2 ))}" =~ $operand ]];then
        IFS= eval "JP_REF_$JP_REFCNT"+='($sep "$JP_OUT")'
        sep=','
      fi
    elif [[ ${JP_OUT:0:1} == [[:digit:]-] ]];then # remove "
      if [[ $JP_OUT =~ $operand ]];then
        IFS= eval "JP_REF_$JP_REFCNT"+='($sep $JP_OUT)'
        sep=','
      fi
    else
      jp.error "=~ only matches strings and numbers" || return
    fi
  done
  eval "JP_REF_$JP_REFCNT"+='(])'
  jp.push "JP_REF_$JP_REFCNT"
}
# END TRANSFORM FUNCTIONS

# BEGIN PRINT FUNCTIONS
function jp.prettyprint {
  local indentchars="$1"
  local i=0
  local len=${#JP_OUT[@]}
  local indentlen=${#indentchars}
  local indent=
  local linebuf=
  while (( i < len  ));do
    local token="${JP_OUT[$i]}"
    case $token in
      [\[{]) if [[ "$linebuf" == *[^[:blank:]]* ]];then
               linebuf="$linebuf$token"
             else
               linebuf="$indent$token"
             fi
             indent="$indent$indentchars"
             if [[ "${JP_OUT[$(($i+1))]}" != [\]}] ]];then
               echo -E "$linebuf"
               linebuf="$indent"
             fi
             ;;
      [\]}]) [[ -n "$indent" ]] && indent="${indent:$indentlen}"
             if [[ "$linebuf" == *[^[:blank:]] ]];then
               if [[ "${linebuf:$((${#linebuf}-1)):1}" == [\[{] ]];then
                 linebuf="$linebuf$token"
               else
                 echo -E "$linebuf"
                 linebuf="$indent$token"
               fi
             else
               linebuf="$indent$token"
             fi
             if [[ "${JP_OUT[$(($i+1))]}" != ',' ]];then
               echo -E "$linebuf"
               linebuf="$indent"
             fi
             ;;
        ',') echo -E "$linebuf,"
             linebuf="$indent";;
        ':') linebuf="$linebuf: ";;
          *) linebuf="$linebuf$token"
    esac
    (( i++ ))
  done
  [[ "$linebuf" == *[^[:blank:]]* ]] && echo -E "$linebuf"
}

function jp.uglyprint {
  local i=0 len=${#JP_OUT[@]}
  while (( i < len  ));do
    echo -nE "${JP_OUT[$i]}"
    (( i++ ))
  done
  echo
}
# END PRINT FUNCTIONS

# BEGIN MAIN
function jp.run {
  # parse stdin
  if [ $JP_INPUT ];then
    jp.parse_json || return
    (( JP_REFCNT++ ))
    eval "JP_REF_$JP_REFCNT"='("${JP_TOKENS[@]}")'
    jp.push "JP_REF_$JP_REFCNT"
  fi

  # process args
  local in_line="$JP_LINE" in_col="$JP_COL" # save stdin parse position
  for arg in "$@";do
    if [ ${arg:0:1} = '.' ];then # transformation command
      eval "jp$arg" || return
    else # json to parse
      JP_TOKENS=()
      JP_LINE=0
      JP_COL=0
      JP_BUF=("$arg")
      jp.parse_json || return
      (( JP_REFCNT++ ))
      eval "JP_REF_$JP_REFCNT"='("${JP_TOKENS[@]}")'
      jp.push "JP_REF_$JP_REFCNT"
    fi
  done
  JP_LINE="$in_line" # restore the stdin parse position
  JP_COL="$in_col"

  # print
  [ $JP_SILENT ] && return 0
  while [ $JP_STACKSIZE -gt 0 ];do
    jp.pop || return
    if [ $JP_PRETTY ];then
      jp.prettyprint "$JP_INDENT"
    else
      jp.uglyprint
    fi
  done
  return 0
}

function jp.main {
  [ -t 1 ] && JP_PRETTY=1 # default to pretty for a tty
  [ -t 0 ] || JP_INPUT=1  # read input if being piped
  while getopts ":pPsti:" opt; do
    case "$opt" in
      'p') JP_PRETTY=1;;
      'P') JP_PRETTY=;;
      't') trap '(jp.trace "${BASH_COMMAND%% *}");' DEBUG; set -T;;
      'i') JP_INDENT="$OPTARG";;
      's') JP_SILENT=1
    esac
    shift $((OPTIND-1))
  done
  [ $JP_INPUT ] && IFS=$'\n' read -rd '' -a JP_BUF
  while :;do
    jp.run "$@" || return
    (( JP_LINE+1 < "${#JP_BUF[@]}" )) && continue # more lines to parse
    break
  done
  [ $JP_INPUT ] && jp.detect_nullbyte
  return 0
}
[ "$BASH_SOURCE" == "$0" ] && jp.main "$@"
# END MAIN
# vim: set ft=sh:
